<!DOCTYPE html><html>
<head>
  <title>You and I</title>
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-F8ET9YT40D"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-F8ET9YT40D');
  </script>
  <style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: black;
    color: white;
  }

  #chatButton {
    position: fixed;
    bottom: 15px;
    left: 15px;
    background: #000;
    color: white;
    border: 1px solid #333;
    border-radius: 50%;
    width: 45px;
    height: 45px;
    cursor: pointer;
    font-size: 20px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
  }

  #chatCard {
  display: none;
  position: fixed;
  bottom: 70px;
  left: 15px;
  width: 250px;
  height: 320px;
  background: #000;
  border-radius: 10px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.6);
  display: flex;
  flex-direction: column;
  font-size: 11px;
  color: white;
  transition: transform 0.1s ease; /* Smooth zoom */
  z-index: 1000; /* Keep on top when zoomed */
  }

  #chatHeader {
    background: #000;
    color: white;
    text-align: center;
    padding: 5px;
    font-size: 12px;
    font-weight: bold;
    border-bottom: 1px solid #444;
  }

  #roleSelect { text-align: center; padding: 10px; }
  #roleSelect button { margin: 5px; padding: 5px 10px; font-size: 11px; cursor: pointer; }

  #messages {
    flex: 1;
    padding: 4px;
    overflow-y: auto;
    font-size: 10px;
    background: #000;
    color: white;
  }

  .msg {
  padding: 3px 5px;
  margin: 3px;
  border-radius: 6px;
  max-width: 80%;
  position: relative;
  font-size: 10px;
  cursor: pointer;
  background: #000;
  color: white;
  border: 1px solid #333;
  word-wrap: break-word;
  }

  .husband {
    margin-right: auto;
    text-align: left;
    border-left: 3px solid #000;
  }

  .wife {
    margin-left: auto;
    text-align: right;
    border-right: 3px solid #000;
  }

  .time { font-size: 7px; color: #bbb; display: block; margin-top: 1px; }
  .deleteBtn { background: none; border: none; color: red; font-size: 9px; cursor: pointer; position: absolute; top: 2px; }
  .husband .deleteBtn { right: 3px; }
  .wife .deleteBtn { left: 3px; }

  .seenStatus { font-size: 8px; color: lightgreen; margin-top: 1px; display: block; }

  #typingIndicator {
    font-size: 9px;
    color: #aaa;
    padding: 2px 6px;
    min-height: 14px;
    font-style: italic;
  }

  #onlineStatus {
    font-size: 9px;
    color: #aaa;
    font-weight: normal;
    display: block;
  }
  #onlineStatus.online { color: lightgreen; }

  .replyBox {
  font-size: 9px;
  background: #111;
  border-left: 3px solid #000;
  padding: 2px 5px;
  margin-bottom: 2px;
  color: #eee;
  }

  #replyPreview {
    display:none;
    font-size: 9px;
    background: #222;
    border-left: 3px solid #000;
    padding: 2px 5px;
    margin: 2px;
    color: #eee;
  }

  #inputArea { 
    display: flex; 
    border-top: 1px solid #444; 
    padding: 3px; 
    flex-direction: column; 
    background: #000;
  }
  
  #msgInput { 
    width: 100%;
    padding: 3px; 
    font-size: 10px; 
    background: #111; 
    color: white; 
    outline:none; 
    border: 1px solid #444; 
    box-sizing: border-box;
  }

  /* Send controls area */
  #sendControls { 
    display: flex; 
    justify-content: flex-end; 
    gap: 5px; 
    margin-top: 3px;
    align-items: center;
  }
  
  /* Bell button styling - Same size as photo/video buttons */
  #notifyButton {
    background: transparent;
    color: white;
    border: 1px solid #333;
    border-radius: 4px;
    font-size: 14px;
    width: 26px;
    height: 22px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    margin-right: 5px;
  }

  #notifyButton:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: scale(1.05);
  }

  #notifyButton:disabled {
    background: #666;
    cursor: not-allowed;
    transform: none;
  }

  /* Photo/video/send buttons - All same size */
  #imgBtn, #vidBtn, #sendBtn {
    padding: 3px;
    background: #000;
    color: white;
    border: 1px solid #333;
    border-radius: 4px;
    font-size: 10px;
    width: 26px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
  }

  /* Send button slightly wider */
  #sendBtn {
    width: 45px;
    padding: 3px 8px;
  }

  /* Container for all buttons in input area */
  .input-buttons {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-top: 3px;
  }
  
  .left-buttons {
    display: flex;
    gap: 5px;
  }
  </style>
</head>
<body>
  <button id="chatButton">üí¨</button>
  
  <div id="chatCard">
    <div id="chatHeader">You and I<span id="onlineStatus"></span></div>
    
    <div id="roleSelect">
      <button onclick="selectRole('husband')">Husband</button>
      <button onclick="selectRole('wife')">Wife</button>
    </div>
    
    <div id="messages" style="display:none;"></div>
    
    <div id="typingIndicator"></div>
    <div id="inputArea" style="display:none;">
      <div id="replyPreview"></div>
      <input id="msgInput" placeholder="Type..." />
      <div class="input-buttons">
        <div class="left-buttons">
          <!-- Bell button will be inserted here by JavaScript for wife -->
          <button id="vidBtn">üé•</button>
          <button id="imgBtn">üì∑</button>
        </div>
        <button id="sendBtn">Send</button>
      </div>
    </div>
  </div>

  <!-- Password Protection -->
  <script>
    const password = "FAMEE";
    let userPass = "";
    while (userPass !== password) {
      userPass = prompt("Enter password:");
      if (userPass === null) {
        document.body.innerHTML = "<h2 style='text-align:center;color:red;'>Access Denied ‚ùå</h2>";
        throw new Error("Closed");
      }
    }
  </script>

  <!-- Firebase + Chat + Pushover -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
    import { getDatabase, ref, push, onChildAdded, onChildRemoved, onValue, update, remove, get, set, serverTimestamp, onDisconnect } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-database.js";

    // ===== FIREBASE CONFIG =====
    const firebaseConfig = {
      apiKey: "AIzaSyDiovfWJSG8yrtz5rA-3ZvjYwmhsWj2g1A",
      authDomain: "you-and-i-aa5ac.firebaseapp.com",
      databaseURL: "https://you-and-i-aa5ac-default-rtdb.firebaseio.com",
      projectId: "you-and-i-aa5ac",
      storageBucket: "you-and-i-aa5ac.firebasestorage.app",
      messagingSenderId: "288741214449",
      appId: "1:288741214449:web:a32998e16e909bef674150"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const chatRef = ref(db, "chat");
    const presenceRef = ref(db, "presence");

    let role = "";
    let replyTo = null;
    let typingTimer = null;

    // ===== ROLE SELECTION =====
    window.selectRole = function(r) {
      role = r;
      messagesLoaded = false;
      document.getElementById("roleSelect").style.display = "none";
      document.getElementById("messages").style.display = "block";
      document.getElementById("inputArea").style.display = "flex";
      document.getElementById("messages").innerHTML = "";

      // ===== PRESENCE: Set online & handle disconnect =====
      const myPresenceRef = ref(db, "presence/" + role);
      // Use a special Firebase trick: write offline state with server timestamp on disconnect FIRST
      onDisconnect(myPresenceRef).update({ online: false, lastSeen: Date.now() });
      // Then set online
      set(myPresenceRef, { online: true, lastSeen: Date.now() });

      // Update lastSeen every 30s while online (so disconnect timestamp is fresh)
      setInterval(() => {
        onDisconnect(myPresenceRef).update({ online: false, lastSeen: Date.now() });
      }, 30000);

      // ===== LISTEN TO OTHER PERSON'S PRESENCE =====
      const other = role === 'husband' ? 'wife' : 'husband';
      const otherName = role === 'husband' ? 'Wifey' : 'Hubby';
      const otherPresenceRef = ref(db, "presence/" + other);
      let lastSeenInterval = null;

      onValue(otherPresenceRef, (snap) => {
        const data = snap.val();
        const statusEl = document.getElementById("onlineStatus");
        if (lastSeenInterval) { clearInterval(lastSeenInterval); lastSeenInterval = null; }

        if (!data) { statusEl.textContent = ""; statusEl.className = ""; return; }

        if (data.online) {
          statusEl.textContent = otherName + " is online";
          statusEl.className = "online";
        } else if (data.lastSeen) {
          function formatLastSeen(ts) {
            const now = Date.now();
            const mins = Math.floor((now - ts) / 60000);
            if (mins < 1) return otherName + " last seen just now";
            if (mins < 60) return otherName + " last seen " + mins + " min ago";
            // Show actual time for today
            const d = new Date(ts);
            const timeStr = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
            const today = new Date();
            if (d.toDateString() === today.toDateString()) {
              return otherName + " last seen today at " + timeStr;
            }
            return otherName + " last seen " + d.toLocaleDateString([], { month: 'short', day: 'numeric' }) + " at " + timeStr;
          }
          statusEl.textContent = formatLastSeen(data.lastSeen);
          statusEl.className = "";
          lastSeenInterval = setInterval(() => {
            statusEl.textContent = formatLastSeen(data.lastSeen);
          }, 30000);
        }
      });

      // ===== LISTEN TO OTHER PERSON'S TYPING =====
      const otherTypingRef = ref(db, "presence/" + other + "/typing");
      onValue(otherTypingRef, (snap) => {
        const typingEl = document.getElementById("typingIndicator");
        typingEl.textContent = snap.val() ? otherName + " is typing..." : "";
      });


      // Create bell button for wife
      const leftButtons = document.querySelector('.left-buttons');
      
      // Remove any existing notify button
      const existingNotifyBtn = document.getElementById('notifyButton');
      if (existingNotifyBtn && existingNotifyBtn.parentNode) {
        existingNotifyBtn.parentNode.removeChild(existingNotifyBtn);
      }

      if (role === 'wife') {
        // Create and insert bell button
        const notifyBtn = document.createElement('button');
        notifyBtn.id = 'notifyButton';
        notifyBtn.innerHTML = 'üîî';
        notifyBtn.title = 'Notify Hubby';
        notifyBtn.onclick = sendNotification;
        
        // Insert bell button at the beginning of left buttons
        leftButtons.insertBefore(notifyBtn, leftButtons.firstChild);
      }
      
      // Mark all existing messages as seen
      markExistingMessagesAsSeen();

      // Load messages
      loadMessages();
    };

    // ===== MARK EXISTING MESSAGES AS SEEN =====
    async function markExistingMessagesAsSeen() {
      if (!role) return;
      
      try {
        const snapshot = await get(chatRef);
        if (snapshot.exists()) {
          const updates = {};
          
          snapshot.forEach((childSnapshot) => {
            const msg = childSnapshot.val();
            const key = childSnapshot.key;
            
            // If message is from the OTHER person and not seen by current user
            if (msg.sender !== role && (!msg.seenBy || !msg.seenBy[role])) {
              updates[`chat/${key}/seenBy/${role}`] = true;
            }
          });
          
          // Update all at once if there are changes
          if (Object.keys(updates).length > 0) {
            await update(ref(db), updates);
          }
        }
      } catch (error) {
        console.error("Error marking messages as seen:", error);
      }
    }

    // ===== NOTIFICATION SYSTEM =====
    function sendNotification() {
      // Only wife can send notifications
      if (role !== 'wife') {
        return;
      }

      // Show sending state
      const notifyBtn = document.getElementById('notifyButton');
      const originalHtml = notifyBtn.innerHTML;
      notifyBtn.innerHTML = '‚è≥';
      notifyBtn.disabled = true;

      // ===== PUSHOVER CREDENTIALS =====
      const PUSHOVER_USER_KEY = "uwe39vejxsq3moswbviuamrybk8fan";
      const PUSHOVER_API_TOKEN = "azq7xhc9jiz95rifgopwxhtdc72avc";

      // Send to Pushover API
      fetch('https://api.pushover.net/1/messages.json', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams({
          token: "azq7xhc9jiz95rifgopwxhtdc72avc",
          user: "uwe39vejxsq3moswbviuamrybk8fan",
          title: "Wifey is Here!",
          message: "Hubbyy i am heree",
          sound: "pushover",
          priority: "1",
          url: window.location.href,
          url_title: "Click to Open Chat"
        })
      })
      .then(response => response.json())
      .then(data => {
        // Reset button after 2 seconds
        setTimeout(() => {
          notifyBtn.innerHTML = originalHtml;
          notifyBtn.disabled = false;
        }, 2000);

        if (data.status === 1) {
          // Success - show checkmark briefly
          notifyBtn.innerHTML = '‚úÖ';
          
          // Send auto-message in chat
          push(chatRef, {
            sender: 'wife',
            text: 'I am waiting pijj come ü•∫',
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true }),
            seenBy: {}
          });

        } else {
          // Failed - show X
          notifyBtn.innerHTML = '‚ùå';
        }
      })
      .catch(error => {
        console.error('Error:', error);
        notifyBtn.innerHTML = '‚ö†Ô∏è';
        setTimeout(() => {
          notifyBtn.innerHTML = originalHtml;
          notifyBtn.disabled = false;
        }, 2000);
      });
    }

    // ===== CHAT FUNCTIONS =====
    // Send text
    document.getElementById("sendBtn").onclick = () => {
      const text = document.getElementById("msgInput").value;
      if (text.trim() !== "") {
        push(chatRef, {
          sender: role,
          text: text,
          reply: replyTo ? replyTo.text : null,
          replySender: replyTo ? replyTo.sender : null,
          time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true }),
          seenBy: {}
        });
        document.getElementById("msgInput").value = "";
        replyTo = null;
        document.getElementById("replyPreview").style.display = "none";
        // Clear typing indicator
        if (role) set(ref(db, "presence/" + role + "/typing"), false);
        clearTimeout(typingTimer);
      }
    };

    // Send on Enter key
    document.getElementById("msgInput").addEventListener("keydown", function(event) {
      if (event.key === "Enter") {
        event.preventDefault();
        document.getElementById("sendBtn").click();
      }
    });

    // ===== TYPING INDICATOR BROADCAST =====
    document.getElementById("msgInput").addEventListener("input", function() {
      if (!role) return;
      const myTypingRef = ref(db, "presence/" + role + "/typing");
      set(myTypingRef, true);
      clearTimeout(typingTimer);
      typingTimer = setTimeout(() => set(myTypingRef, false), 2000);
    });

    // Image send
    document.getElementById("imgBtn").onclick = () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(ev) {
          push(chatRef, {
            sender: role,
            image: ev.target.result,
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true }),
            seenBy: {}
          });
        };
        reader.readAsDataURL(file);
      };
      input.click();
    };

    // Video send
    document.getElementById("vidBtn").onclick = () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "video/*";
      input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(ev) {
          push(chatRef, {
            sender: role,
            video: ev.target.result,
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true }),
            seenBy: {}
          });
        };
        reader.readAsDataURL(file);
      };
      input.click();
    };

    // Reply enable
    function enableReply(key, msg) {
      replyTo = { key, text: msg.text, sender: msg.sender };
      document.getElementById("replyPreview").innerText = msg.sender + ": " + msg.text;
      document.getElementById("replyPreview").style.display = "block";
    }

    // Render message
    function renderMsg(key, msg) {
      let msgDiv = document.getElementById("msg-" + key);
      if (!msgDiv) {
        msgDiv = document.createElement("div");
        msgDiv.className = "msg " + msg.sender;
        msgDiv.id = "msg-" + key;
        document.getElementById("messages").appendChild(msgDiv);

        // ===== LIVE SEEN STATUS UPDATE =====
        if (msg.sender === role) {
          const msgSeenRef = ref(db, "chat/" + key + "/seenBy");
          onValue(msgSeenRef, (snap) => {
            const seenBy = snap.val();
            const opposite = role === 'husband' ? 'wife' : 'husband';
            const seenEl = document.getElementById("seen-" + key);
            if (seenEl) seenEl.textContent = (seenBy && seenBy[opposite]) ? "Seen ‚úÖ" : "";
          });
        }
      }

      let deleteBtn = "";
      if (msg.sender === role) {
        deleteBtn = `<button class="deleteBtn" onclick="deleteMsg('${key}')">‚úñ</button>`;
      }

      let content = "";
      if (msg.reply) {
        content += `<div class="replyBox">${msg.replySender}: ${msg.reply}</div>`;
      }

      const isMedia = !!(msg.image || msg.video);

      if (msg.text) content += msg.text;
      if (msg.image) content += `<br><img src="${msg.image}" width="100">`;
      if (msg.video) content += `<br><video src="${msg.video}" width="150" controls></video>`;

      msgDiv.innerHTML = `
        ${content}
        <span class="time">${msg.time || ""}</span>
        ${deleteBtn}
        <span class="seenStatus" id="seen-${key}"></span>
      `;

      // Only allow reply on text messages (not photos/videos)
      if (!isMedia) {
        // Swipe reply
        msgDiv.addEventListener("touchstart", function(e) {
          this.touchStartX = e.changedTouches[0].screenX;
        });
        msgDiv.addEventListener("touchend", function(e) {
          let touchEndX = e.changedTouches[0].screenX;
          if (this.touchStartX - touchEndX > 50) {
            enableReply(key, msg);
          }
        });
        // Double click reply
        msgDiv.ondblclick = () => enableReply(key, msg);
      }

      // Auto-scroll
      const msgBox = document.getElementById("messages");
      msgBox.scrollTop = msgBox.scrollHeight;
    }

    // ===== LOAD MESSAGES: Existing all at once, then new ones live =====
    let messagesLoaded = false;

    async function loadMessages() {
      // 1. Load ALL existing messages at once (instant, no trickle)
      const snapshot = await get(chatRef);
      if (snapshot.exists()) {
        snapshot.forEach((child) => {
          renderMsg(child.key, child.val());
          // Mark as seen if from other person
          if (child.val().sender !== role) {
            update(ref(db, "chat/" + child.key), { ["seenBy/" + role]: true });
          }
        });
      }
      messagesLoaded = true;

      // 2. After loading history, listen ONLY for brand new messages
      onChildAdded(chatRef, (snap) => {
        if (!messagesLoaded) return; // skip ‚Äî already rendered above
        const msg = snap.val();
        const key = snap.key;
        if (!document.getElementById("msg-" + key)) {
          renderMsg(key, msg);
          if (msg.sender !== role) {
            update(ref(db, "chat/" + key), { ["seenBy/" + role]: true });
          }
        }
      });
    }

    // Delete message
    window.deleteMsg = function(key) {
      remove(ref(db, "chat/" + key));
    };

    // Remove from UI
    onChildRemoved(chatRef, (snapshot) => {
      const msgDiv = document.getElementById("msg-" + snapshot.key);
      if (msgDiv) msgDiv.remove();
    });

    // Toggle chat
    document.getElementById("chatButton").onclick = () => {
      const card = document.getElementById("chatCard");
      card.style.display = card.style.display === "none" ? "flex" : "none";
    };
// ===== MOUSE WHEEL ZOOM (No Ctrl needed) =====
let currentZoom = 1;
const chatCard = document.getElementById('chatCard');
const messages = document.getElementById('messages');

// Listen for mouse wheel on the chat card
chatCard.addEventListener('wheel', function(e) {
  // Prevent page scrolling when zooming chat
  e.preventDefault();
  
  // Zoom IN when scrolling UP
  if (e.deltaY < 0) {
    currentZoom += 0.1;
    if (currentZoom > 1.5) currentZoom = 1.5;
  } 
  // Zoom OUT when scrolling DOWN
  else {
    currentZoom -= 0.1;
    if (currentZoom < 0.8) currentZoom = 0.8;
  }
  
  // Apply zoom
  chatCard.style.transform = `scale(${currentZoom})`;
  chatCard.style.transformOrigin = 'bottom left';
  messages.style.fontSize = (10 * currentZoom) + 'px';
  
  // Change chat position so it stays visible
  const newBottom = 70 + ((320 * (currentZoom - 1)) / 2);
  const newLeft = 15 + ((250 * (currentZoom - 1)) / 2);
  chatCard.style.bottom = `${newBottom}px`;
  chatCard.style.left = `${newLeft}px`;
}, { passive: false });
  </script>
</body>
</html>
